## Syntax

 [~]:             ../../panelcode-data/script2/output/~.svg
 [(~)]:           ../../panelcode-data/script2/output/(~).svg
 [5(~)]:           ../../panelcode-data/script2/output/5(~).svg
 [3_5(~)]:           ../../panelcode-data/script2/output/3_5(~).svg

 [1_2_~]:         ../../panelcode-data/script2/output/1_2_~.svg
 [3_(~)]:       ../../panelcode-data/script2/output/3_(~).svg
 [3(r2+~,1)]:   ../../panelcode-data/script2/output/3(r2+~,1).svg

 [3(1+c2+1)]:   ../../panelcode-data/script2/output/3(1+c2+1).svg

 [0]:             ../../panelcode-data/script2/output/0.svg
 [3]:             ../../panelcode-data/script2/output/3.svg
 [4]:             ../../panelcode-data/script2/output/4.svg
 [5]:             ../../panelcode-data/script2/output/5.svg

[1_2]:           ../../panelcode-data/script2/output/1_2.svg
[1_2_0]:         ../../panelcode-data/script2/output/1_2_0.svg
[1_2_3]:         ../../panelcode-data/script2/output/1_2_3.svg
 [1_2_3_1_2_3]:   ../../panelcode-data/script2/output/1_2_3_1_2_3.svg
 [(r2+1,1)_(r2+1,1)]: ../../panelcode-data/script2/output/(r2+1,1)_(r2+1,1).svg

 [1_2_3_4_5_6]:   ../../panelcode-data/script2/output/1_2_3_4_5_6.svg
 [1_3_2_4]:       ../../panelcode-data/script2/output/1_3_2_4.svg
 [2]:             ../../panelcode-data/script2/output/2.svg
 [2_(1+0)]:       ../../panelcode-data/script2/output/2_(1+0).svg
 [2_2]:           ../../panelcode-data/script2/output/2_2.svg
 [2(c2+1)]:       ../../panelcode-data/script2/output/2(c2+1).svg
[2_2_2_1_1_2_1]: ../../panelcode-data/script2/output/2_2_2_1_1_2_1.svg
[2_2++3_3]:      ../../panelcode-data/script2/output/2_2++3_3.svg
[2_3]:           ../../panelcode-data/script2/output/2_3.svg
[2_3_2]:         ../../panelcode-data/script2/output/2_3_2.svg
[2_3_2++]:       ../../panelcode-data/script2/output/2_3_2.svg
 [2_3_3(1+r2,1)]: ../../panelcode-data/script2/output/2_3_3(1+r2,1).svg
 [2_3_5]:         ../../panelcode-data/script2/output/2_3_5.svg
[2_2_5(r2+2,2)]: ../../panelcode-data/script2/output/2_2_5(r2+2,2).svg
[2_5_1_3_2]:     ../../panelcode-data/script2/output/2_5_1_3_2.svg
 [3(r2+1,1)]:     ../../panelcode-data/script2/output/3(r2+1,1).svg
[3(1+r2,1)]:     ../../panelcode-data/script2/output/3(1+r2,1).svg
[3_3]:           ../../panelcode-data/script2/output/3_3.svg
[3_3_3]:         ../../panelcode-data/script2/output/3_3_3.svg
[3_3_3_3_3]:     ../../panelcode-data/script2/output/3_3_3_3_3.svg

 [3(r2,1)]:       ../../panelcode-data/script2/output/3(r2,1).svg
[4(r3+1,1,1)]:   ../../panelcode-data/script2/output/4(r3+1,1,1).svg
[4(1+r3,1,1)]:   ../../panelcode-data/script2/output/4(1+r3,1,1).svg
[5(1+r2+1,2)]:   ../../panelcode-data/script2/output/5(1+r2+1,2).svg
[5(r2+1+r2,1)]:  ../../panelcode-data/script2/output/5(r2+1+r2,1).svg
[5(r2+2,2)]:     ../../panelcode-data/script2/output/5(r2+2,2).svg
[5(2+r2,2)]:     ../../panelcode-data/script2/output/5(2+r2,2).svg

[0_(2+0+2)_0]:   ../../panelcode-data/script2/output/0_(2+0+2)_0.svg
[0_1_(1+0)]:     ../../panelcode-data/script2/output/0_1_(1+0).svg

[0_2_0]:         ../../panelcode-data/script2/output/0_2_0.svg
[0_3_0]:         ../../panelcode-data/script2/output/0_3_0.svg
[3(r2+0,1)]:     ../../panelcode-data/script2/output/3(r2+0,1).svg

[2_(1,0)]:       ../../panelcode-data/script2/output/2_(1,0).svg
 [2_5(1+r2+r2+r2,1)_4(r2+r2+1,1)]: ../../panelcode-data/script2/output/2_5(1+r2+r2+r2,1)_4(r2+r2+1,1).svg

[3_3_3_3]:       ../../panelcode-data/script2/output/3_3_3_3.svg
[4_4_4_4_4]:     ../../panelcode-data/script2/output/4_4_4_4_4.svg
[6_6_6_6_6_6_6_6_6]: ../../panelcode-data/script2/output/6_6_6_6_6_6_6_6_6.svg

[r2+4+c2r2,2c2]: ../../panelcode-data/script2/output/r2+4+c2r2,2c2.svg

### Rows: `_`



Each number signifies a row: 

|  Panelcode      |  render            |
|-----------------|--------------------|
|  `2_2`          |  ![][2_2]          |  
|  `2_3_5`        |  ![][2_3_5]        |
|  `1_3_2_4`      |  ![][1_3_2_4]      |
|  `1_2_3_4_5_6`  |  ![][1_2_3_4_5_6]  |


### Groups: `( )`

#### group intro A

Groups specify complex row layouts -- in particular, stacking together panels of different row depths and column heights into a single unit. These are differences in width and height are indicated in groups by 'rowspan' (`r2`, `r3` etc.) and 'colspan' (`c2`,`c3`).

	(1.r2 + 4 + 1.c2.r2, 2.c2)

This group contains a single panel two rows high (1.r2), four more panels (4), then a single panel that is two-by-two (1.c2.r2). On the next row (,) are two mmore panels, each two columns wide (2.c2).

This can be simplified by ommiting the optional `.` separator.

It can be further simplified by ommiting the optional `1` in front of any single panel with a row or column modifier. Here is the result:

	(r2+4+c2r2,2c2)

![][r2+4+c2r2,2c2.svg]

Consider this simple group:

|  Panelcode                         |  render                               |
|------------------------------------|---------------------------------------|
|  `3`                               |  ![][3]                               |
|  `3(r2+1,1)`                       |  ![][3(r2+1,1)]                       |

This group reads:

-  `3` there are three panels in this row
-  `(` grouped as follows:
   -  `r2` = `1.r2` 1 panel, stretching 2 rows deep
      -   `+` and
      -   `1` 1 panel
      -   `,` followed on the next row by
   -   `1` a panel
-  `)`

When the row number `3` is expanded by a group `3()` it becomes a "count-hint" -- nice for readability, but optional. With or without the count-hint, `3(r2+1,1)` and `(r2+1,1)` both describe the same layout.

Panelgroups scale panels with row and column spans. Multi-row panels (`r2`, `r3` etc.) take up space in the rows below them, while on those next rows new cells "fill-in" the unoccupied spaces.

Groups and rows may be stacked horizontally (`_`) to form a single layout.

| Panelcode                          |  render                               |  description         |
|------------------------------------|---------------------------------------|----------------------|
|  `2_3_3(1+r2,1)`                   |  ![][2_3_3(1+r2,1)]                   |  A row of 2 panels, 3 panels, and 3 panels. The third row consists of a panel, a double-height panel, and a last panel filing in the next line.     |
|  `2_5(1+r2+r2+r2,1)_4(r2+r2+1,1)`  |  ![][2_5(1+r2+r2+r2,1)_4(r2+r2+1,1)]  |  A row of 2 panels, 5 panels, and 4 panels. The second and third rows each combine double-height panels and single panels into a block.             |

#### group intro B

Sometimes panels span multiple rows, or panel columns overlap in meaningful ways. A `group` expands a count from one row into a multi-row block with detailed layout information. A group layout is defined in parentheses: `(r2+1,1)`. It may be proceeded by an optional number -- called a count hint -- indicating the number of panels in the group: `3(r2+1,1)`.

Example groups:

	3(r2+1,1)
	4(r2+1+r2,1)
	4(1+r2+1,2)

'+' indicates panels on the same group row, while ',' indicates a new group row.

	r (rowspan, or # of rows high)
	c (colspan, or # of cols wide)

The suffix 'r' indicates a group-row height:

	2   = 2 panels
	3   = 3 panels
	 r2 = 1 panel,  2 rows high
	 r3 = 1 panel,  3 rows high
	2r3 = 2 panels, 3 rows high each

So in the group:

	7(r3+2r2+1,1,2)

...notice that the subsequent group rows "fill in" the gaps left by the panels above. This is exactly how HTML tables work.

Within the group parentheses 'c' indicates a column.

 	 c2 = 1 panel,  2 columns wide
 	 c3 = 1 panel,  3 columns wide
	2c3 = 2 panels, 3 columns wide each

When appearing bare, modifiers refer to a single panel. 'r3' = '1r3'. When preceded by a count, modifiers apply to each panel in the count:

	(3r2+1,1) = (r2+r2+r2+1,1)

Both rowspan and colspan can be defined in a group, and then can be combined.

	(r3+2r2+1,1,c2)

	(1+r2c2+1,r2+r2,c2)

	(2r2c2,1,r2,4)

Groups are assembled together into a layout using '_' -- just like row counts:

	row counts layout: 3_3_4
	row groups layout: 3(r2+1,1)_4(r2+1+r2,1)_4(1+r2+1,2)

A single layout will often mix simple counts and complex groups:

	3_3_4(1+r2+1,2)

Empty groups are equivalent to a simple row number:

	3_3_4() = 3_3_4(4) = 3_3_4

	Note: You can use empty groups as placeholders for more detailed layout data collection.
	Simply

Groups can be "bare", without a preceding number (e.g. for convenient fast data entry):

	(1+r2+1,2) = 4(1+r2+1,2)

Note: row groups can be invalid due to a mismatch between the initial count

 number/group mismatch:

	group numbers 
	3(r2+1+r2,1) -- number is 3, group details 4

Note: sometimes a layout contains now horizontal divisions at all, and must be specified by a single group. For example, this 4x4 layout can only be defined in a continuous group:

	12(r2+3,r2+2,1+r2+1,3)

By extension, any "normal" layout could be defined as a single group. For example, this 3x3 layout:
	
	3x3
	= 3_3_3
	= 9(3,3,3)
	= 9(1+1+1,1+1+1,1+1+1)

#### Groups that reduce to simple rows

Groups `( )` which contain only simple rows are reduced to simple rows.

|                                  |  original     |  Panelcode |  render        |
|----------------------------------|---------------|------------|----------------|
|  group with simple row           |  `1_(2)`      |  `1_2`     |  ![][1_2]      |
|  groups with simple rows         |  `(1)_(2)`    |  `1_2`     |  ![][1_2]      |
|  empty groups with hints         |  `1()_2()`    |  `1_2`     |  ![][1_2]      |
|  group with simple rows          |  `1_(2,3)`    |  `1_2_3`   |  ![][1_2_3]    |
|  group with simple rows (blank)  |  `1_(2,0)`    |  `1_2_0`   |  ![][1_2_0]    |
|  group with simple rows (uncod)  |  `1_(2,~)`    |  `1_2_~`   |  ![][1_2_~]    |


|                                  |  original     |  Panelcode |
|----------------------------------|---------------|------------|
|  empty groups                    |  `()_()`      |  invalid   |
|  group with missing row          |  `1_(2,)`     |  invalid   |
|  group with missing rows         |  `1_(,)`      |  invalid   |
|  group with missing rows         |  `3(,)`       |  invalid   |


### Blanks: `0`

Blanks indicate blank areas in a layout.

Whole pages, rows, or individual panels may be blank -- not empty panels, but missing entirely from the layout (with no panel borders indicated).

The zero marker (`0`) acts as a placeholder to indicate these empty areas in the layout -- 'zero-panels', 'zero-row', or 'zero-pages'. Panelcode renderers will place an invisible panel' to fill the space indicated.

|                        |  Panelcode    |  render                         |
|------------------------|---------------|---------------------------------|
|  blank page            |  `0`          |  ![][0]                         |
|  blank rows            |  `0_2_0`      |  ![][0_2_0]                     |
|  blank in group (ERROR)        |  `2_(1+0)`    |  ![][2_(1+0)]                   |
|  blank in group        |  `3(r2+0,1)`  |  ![][3(r2+0,1)]                 |


#### Blank rendering

Internally, the 0 panel is represented as 1.blank -- a single panel with special rendering features which will not be included in panel counts.

-  `0_2_0` = `1.blank_2_1.blank`
-  `3(r2+0,1)` = `3(r2+1.blank,1)`


#### No blanks as a group hint

`0` is not a meaningful group hint.

	0(r2+1,1) What should a 0 hint do? Allowable? Meaningful? Maybe there are reasons people would want to do it to hack things in and out of analysis...?
	0(~) ...would this be meaningful? Blank space, but also uncodeable at the same time?
	0()  ...

	~(r2+1,1)  What should an uncoded hint do? Meaningful? Parse error?
	~(0) What should this do?
	~()  ...


#### Blanks vs. ommitting group panels

Rather than ommiting a panel at the end of a group row, specify a blank.

Ommitting a panel may generate a similar  visual output under certain circumstances, however it may also change the markup in unpredictable ways, and makes it difficult to search, render, and validate a panelcode. Instead, specify the blank.

|                                     |  Panelcode    |  render                      |
|-------------------------------------|---------------|------------------------------|
|  missing panel in rowgroup (wrong)  |  `3(r2,1)`    |                              |
|    blank panel in rowgroup (right)  |  `3(r2+0,1)`  |  ![][3(r2+0,1)]              |


### Uncoded: `~`

Some layouts elements cannot be encoded or rendered in Panelcode. The uncoded marker (`~`) acts as a placeholder for these. Panelcode renderers will place a specially marked or styled 'panel' to fill the space indicated.

The row separator is used in an empty group to indicate that the group layout is not encoded.

|  uncoded markers               |  Panelcode   |  render         |
|--------------------------------|--------------|-----------------|
|  uncoded page                  |  `~`         |  ![][(~)]       |
|  uncoded group                 |  `3_(~)`     |  ![][3_(~)]     |
|  uncoded panel in group        |  `(r2+~,1)`  |  ![][3(r2+~,1)] |

Uncoded pages and groups `(~)` may optionally be prefixed by a panel count: `3(~)`.

|  uncoded markers               |  Panelcode   |  render         |
|--------------------------------|--------------|-----------------|
|  uncoded page w/count hint     |  `5(~)`      |  ![][5(~)]      |
|  uncoded group w/count hint    |  `3_5(~)`    |  ![][3_5(~)]    |
|  uncoded panel in group w/hint |  `3(r2+~,1)` |  ![][3(r2+~,1)] |

If a count is included, renderers may use a row of specially marked panels as a layout placeholder, rather than a single marked panel.


#### Uncoded rendering


Internally, the `~` panel is represented as `1.uncoded` -- a single panel with special rendering features. For the purposes of panel counts an uncoded panel counts as '1' unless it is part of a hinted group.

-  `~_2_~` = `1.buncoded_2_1.uncoded`
-  `3(r2+~,1)` = `3(r2+1.uncoded,1)`



> > If the _ marker wasn't being used, perhaps it could be used for uncoded? Although ~ seems more semantic, and less likely to be mistaken for space. Perhaps the underscore should be used instead of 0 to code for blank. After all, there is 1 panel.

		(~)		(_)		(-)


### Shorthands: `[ ]`

Panelcode supports a variety of shorthand syntaxes to make reading and writing panelcode easier and more expressive.

For example:

-  "quick" shorthand describes a layout using only rows
-  "alpha" shorthand summarizes small groups of  

Shorthands are indicated within `[ ]`. Each shorthand defines a row or group of rows.

Shorthands are pre-processed and replaced before a panelcode is manipulated or rendered. In general they are expanded into a canonical rowcode form.

**Examples:**

|  shorthand   |  code    |             |                |  rowcode        |  render               |
|--------------|----------|-------------|----------------|-----------------|-----------------------|
|  alpha       |  `[C]`   |  `[C].a`    |  `[C].alpha`   | `3(r2+1,1)`     |  ![C][3(r2+1,1)]      |
|  span        |  `[2L]`  |  `[2L].s`   |  `[2L].span`   | `2(c2+1)`       |  ![2L][2(c2+1)]       |
|  vert        |          |  `[212].v`  |  `[212].vert`  | `5(1+r2+1,2)`   |  ![v][5(1+r2+1,2)]     |
|              |          |             |                |                 |                       |
|  multipler   |  `4[*5]` |             |                | `4_4_4_4_4`     |  ![][4_4_4_4_4]       |


**A table of shorthands:**

|  shorthand  |  short   |  full          |  rowcode        |  render               |
|-------------|----------|----------------|-----------------|-----------------------|
|  quick      |  `33`    |  `[33].quick`  |  `3_3`          |  ![][3_3]             |
|  quick      |  `25132` |  `[25132].quick` |  `2_5_1_3_2`  |  ![][2_5_1_3_2]       |
|             |          |                |                 |                       |
|  alpha      |  `[C]`   |  `[C].alpha`   | `3(r2+1,1)`     |  ![C][3(r2+1,1)]      |
|  alpha      |  `[D]`   |  `[D].alpha`   | `3(1+r2,1)`     |  ![D][3(1+r2,1)]      |
|  alpha      |  `[E]`   |  `[E].alpha`   | `4(r3+1,1,1)`   |  ![E][4(r3+1,1,1)]    |
|  alpha      |  `[B]`   |  `[B].alpha`   | `4(1+r3,1,1)`   |  ![B][4(1+r3,1,1)]    |
|  alpha      |  `[I]`   |  `[I].alpha`   | `5(1+r2+1,2)`   |  ![I][5(1+r2+1,2)]    |
|  alpha      |  `[O]`   |  `[O].alpha`   | `5(r2+1+r2,1)`  |  ![O][5(r2+1+r2,1)]   |
|             |          |                |                 |                       |
|  span       |  `[2L]`  |  `[2L].span`   | `2(c2+1)`       |  ![2L][2(c2+1)]       |
|  span       |  `[2R]`  |  `[2R].span`   | `2(1+c2)`       |  ![2R][2(1+c2)]       |
|  span       |  `[3L]`  |  `[3L].span`   | `3(c2+2)`       |  ![3L][3(c2+2)]       |
|  span       |  `[3R]`  |  `[3R].span`   | `3(2+c2)`       |  ![3R][3(2+c2)]       |
|  span       |  `[3W]`  |  `[3W].span`   | `3(1+c2+1)`     |  ![3W][3(1+c2+1)]     |
|  span       |  `[3N]`  |  `[3N].span`   | `3(c2+1+c2)`    |  ![3N][3(c2+1+c2)]    |
|  span       |  `[4L]`  |  `[4L].span`   | `4(c2+3)`       |  ![4L][4(c2+3)]       |
|  span       |  `[4R]`  |  `[4R].span`   | `4(3+c2)`       |  ![4R][4(3+c2)]       |
|  span       |  `[4W]`  |  `[4W].span`   | `4(1+c2+c2+1)`  |  ![4W][4(1+c2+c2+1)]  |
|  span       |  `[4N]`  |  `[4N].span`   | `4(c2+2+c2)`    |  ![4N][4(c2+2+c2)]    |
|  span       |  `[5L]`  |  `[5L].span`   | `5(c2+4)`       |  ![5L][5(c2+2)]       |
|  span       |  `[5R]`  |  `[5R].span`   | `5(4+c2)`       |  ![5R][5(2+c2)]       |
|  span       |  `[5W]`  |  `[5W].span`   | `5(1+c3+1)`     |  ![5W][5(1+c2+1)]     |
|  span       |  `[5N]`  |  `[5N].span`   | `5(c2+3+c2)`    |  ![5N][5(c2+1+c2)]    |
|             |          |                |                 |                       |
|  vertical   | `[12V]`  |  `[12].vert`   | `3(r2+1,1)`     |  ![][3(r2+1,1)]       |
|  vertical   | `[21V]`  |  `[21].vert`   | `3(1+r2,1)`     |  ![][3(1+r2,1)]       |
|  vertical   | `[13V]`  |  `[13].vert`   | `4(r3+1,1,1)`   |  ![][4(r3+1,1,1)]     |
|  vertical   | `[31V]`  |  `[31].vert`   | `4(1+r3,1,1)`   |  ![][4(1+r3,1,1)]     |
|  vertical   | `[212V]` |  `[212].vert`  | `5(1+r2+1,2)`   |  ![][5(1+r2+1,2)]     |
|  vertical   | `[121V]` |  `[121].vert`  | `5(r2+1+r2,1)`  |  ![][5(r2+1+r2,1)]    |
|  vertical   | `[122V]` |  `[122].vert`  | `5(r2+2,2)`     |  ![][5(r2+2,2)]       |
|  vertical   | `[221V]` |  `[221].vert`  | `5(2+r2,2)`     |  ![][5(2+r2,2)]       |


#### Quick shorthand: `333`

Quick shorthand syntax describes a layout using only row counts, and with no row separators (`_`). A quick panelcode is a string of 2 or more digits

```Panelcode
	333            # quick 3_3_3
	2221121        # quick 2_2_2_1_1_2_1
```

![][2_2_2_1_1_2_1]

Quick syntax will be expanded automatically if the string contains 2 or more digits and nothing else -- no row separators `_`, groups `( )`, or shortcodes `[ ]` etc.

-  Row separators `_` are required for any layout referring to a two-digit number greater than 9.
-  If used, row separators must be used throughout a Panelcode line -- they cannot be mixed.
-  In the case of a single row layout >9, use a group

```Panelcode
	1212     # = 1 + 2 + 1 + 2
	12_12    # = 12 + 12
	1_2_12   # = 1 + 2 + 12
```

```Panelcode
	12112_12   # = 12112 + 12 !!
	           # ...NOT 1 + 2 + 1 + 1 + 2 + 12
```

![][2_2_2_1_1_2_1]
![][3_3_3_3_3]



#### Alpha shorthand: `[C]`, `[D]`, ... 

Some small groups are extremely common, occuring over and over again.

Some of the most common rowgroups in comics are various configurations including one or more double-height rows, e.g. `3(r2+1,1)`:

![C][3(r2+1,1)]

Alpha shorthand 


	3A = 
	3C = 
	3D = 
	3U = 
	4H = 
	4I = 

	3C_4H_4I --> 3(r2+1,1)_4(r2+1+r2,1)_4(1+r2+1,2)


#### Span shorthand: `[2L]`, `[3W]`,  ...

By default panels in a row are equal width. Within a rowgroup, column span markers (e.g. `c2`) can be used to make panels proportionally wider or narrower within their row. However, this can be quite verbose in a way that is harder to read and to write.

Consider a 3-panel row with a wider center panel. "3W" makes encoding and easier.

|            |  spancode  |  rowcode      |  render             |
|------------|------------|---------------|---------------------|
| a '3-wide' |  `[3W]`    |  `3(1+c2+1)`  |  ![][3(1+c2+1)]     |

|  rowcode without spans  |  render               |
|-------------------------|-----------------------|
|   `2`                   |  ![2][2]              |
|   `3`                   |  ![3][3]              |
|   `4`                   |  ![4][4]              |
|   `5`                   |  ![5][5]              |


|  spancode           |  rowcode        |  render               |
|---------------------|-----------------|-----------------------|
|  `[2L] / [2Left]`   |  `2(c2+1)`      |  ![2L][2(c2+1)]       |
|  `[2R] / [2Right]`  |  `2(1+c2)`      |  ![2R][2(1+c2)]       |
|  `[3L] / [3Left]`   |  `3(c2+2)`      |  ![3L][3(c2+2)]       |
|  `[3R] / [3Right]`  |  `3(2+c2)`      |  ![3R][3(2+c2)]       |
|  `[3W] / [3Wide]`   |  `3(1+c2+1)`    |  ![3W][3(1+c2+1)]     |
|  `[3N] / [3Narrow]` |  `3(c2+1+c2)`   |  ![3N][3(c2+1+c2)]    |
|  `[4L] / [4Left]`   |  `4(c2+3)`      |  ![4L][4(c2+3)]       |
|  `[4R] / [4Right]`  |  `4(3+c2)`      |  ![4R][4(3+c2)]       |
|  `[4W] / [4Wide]`   |  `4(1+c2+c2+1)` |  ![4W][4(1+c2+c2+1)]  |
|  `[4N] / [4Narrow]` |  `4(c2+2+c2)`   |  ![4N][4(c2+2+c2)]    |
|  `[5L] / [5Left]`   |  `5(c2+4)`      |  ![5L][5(c2+2)]       |
|  `[5R] / [5Right]`  |  `5(4+c2)`      |  ![5R][5(2+c2)]       |
|  `[5W] / [5Wide]`   |  `5(1+c3+1)`    |  ![5W][5(1+c2+1)]     |
|  `[5N] / [5Narrow]` |  `5(c2+3+c2)`   |  ![5N][5(c2+1+c2)]    | 


	2L_2R_2L = (c2+1)_(1+c2)_(c2+1)
	2_2_2


#### Vertical shorthand: `[121V]`

While alpha shorthand describes some common small groups with row-spanning panels, vertical shorthand is a more general description of any group with only rowspans (and no column spans). The (r2+1,1) `[C]` pattern is written [12V] in vertical shorthand -- 1 panel in the first column, and two in the second column. `[E]` is written [13V]. Vertical shorthand can also describe many groups that have no alpha codes -- such as [112V], [1112V], and [11112V].

A group that mixes panels of 2, 3, 4, and 5+ rowspans can be extremely verbose and complex to encode in rowcode. For example, a rowgroup with a column of 5 panels next to a column of 3 is extremely hard to work out and then manually encode in rowcode:

|----------|--------------------------------------|
|  rowcode | `(r3+r5,,,r5,,r3,r5,,,r5,r3,,r5,,,)` |
| vertical | `[53V]`                              |



#### Multiplier shorthand: `[*3]`

The multiplier shorthand (`[*3]`) expands n repetitions of the previous term or group.

|  grid shorthand    |  expansion                   |  render                       |  note              |
|--------------------|------------------------------|-------------------------------|--------------------|
|  `3[*2]`           |  `3_3`                       |  ![][3_3]                     | repeat simple rows |
|  `3[*5]`           |  `3_3_3_3_3`                 |  ![][3_3_3_3_3]               | "   "              |
|  `[123][*2]`       |  `[123]_[123]`=`1_2_3_1_2_3` |  ![][1_2_3_1_2_3]             | "   "              |
|  `[3C][*2]`        |  `[3C]_[3C]` `(r2+1,1)_(r2+1,1)`  | ![][(r2+1,1)_(r2+1,1)]     | repeat shorthand   |
|  `[v212][*2]`      |  `[v212]_[v212]` `(r2+1,1)_(r2+1,1)`  | ![][(r2+1,1)_(r2+1,1)] | "   "              |
|  `(r2+r2+1,1)[*2]` |  `(r2+r2+1,1)_(r2+r2+1,1)`   |  ![][(r2+r2+1,1)(r2+r2+1,1)]` | repeat group       |

The multiplier is expanded before all other shorthands are applied.

> **NOTE:** Low multipliers of simple rows does not enhance readability or save space:
> `2[*2]` is not shorter or simpler than `2_2`.

> **DEV NOTE:** Multiplier shorthand was originally called grid shorthand or "grid code", because a multiplier * a rownum would produce a grid, e.g. 3*5 = 3x5 grid. However, the main use of the multiplier is actually in duplicating complex rowgroups -- which do not in fact produce grids.

> **Idea:** Could be `[,3]` `[+3]` `[_3]` -- repetition syntax makes more sense than multipler, and it could repeat across a row (`+`) or it could repeat rows (`_` / `,`). This notation might make more sense if the row separator in groups and out of groups is the same (e.g. `,`). (`+`) would be very rare -- after all, `3` is already the shorthand for `1[+3]`, and "+3" might be confusing -- that is, it might look like 4. Need to think more about this.

#### Mixing shorthands

Shorthands may offer different ways of encoding the same row group, however these expand to the same rowcode. For example, these alpha and vertical shorthands encode the same layout -- and expand the same way.

|  render               |  alpha  |  vertical  |  rowcode        |
|-----------------------|---------|------------|-----------------|
|  ![3C][3(r2+1,1)]     |  [C]    |   [12V]    |  `3(r2+1,1)`    |
|  ![3D][3(1+r2,1)]     |  [D]    |   [21V]    |  `3(1+r2,1)`    |
|  ![4E][4(r3+1,1,1)]   |  [E]    |   [13V]    |  `4(r3+1,1,1)`  |
|  ![4D][4(1+r3,1,1)]   |  [B]    |   [31V]    |  `4(1+r3,1,1)`  |
|  ![5I][5(1+r2+1,2)]   |  [I]    |  [212V]    |  `5(1+r2+1,2)`  |
|  ![5H][5(r2+1+r2,1)]  |  [O]    |  [121V]    |  `5(r2+1+r2,1)` |

Different shorthands may be mixed in different layout strings in a panelcode data file. Shorthand groups can be mixed with each other in the same panelcode string.

1. `[C]_[C]`    
2. `[12V]_[12V]`
3. `[C]_[12V]`
4. `[12V]_[C]`
5. `[12].verical_[C].alpha`

...will all expand to the same rowcode layout:

`3(r2+1,1)_3(r2+1,1)`

However, each shorthand processor is separate, and different shorthand codes cannot be mixed together into new codes. Invalid constructs like `[B12V]` or `[CC4L]` will not be recognized.

Shorthand groups can also be combined with multipler syntax -- just like row numbers or groups.

`4_[C][*3]_[2L][*2]_[212].v`

-  ... a 4-panel row,
-  and a C-shaped row, x3,
-  and a 2-panel row, wider on the Left, x2,
-  and a row described as vertical stacks of 2-1-2 panels.

This layout expands as follows:

	4_[C][*3]_[2L][*2]_[212].v =
	4_3(r2+1,1)_3(r2+1,1)_3(r2+1,1)_2(c2+1)_2(c2+1)_5(1+r2+1,2)


#### Extending shorthands

Shorthand can accommodate unknown markup. These rows will be marked as 'uncoded' for rendering,
and hinted with a placeholder of the correct rowcount if a count decorator is provided: `5[foo]`.
Tokens will be passed through as classes for styling.

|  shorthand   |  code    |             |                |  Panelcode      |  render               |
|--------------|----------|-------------|----------------|-----------------|-----------------------|
|  unknown     |  `[foo]` |  `[foo].b`  |  `[foo].bar`   |   `(~)`         |  ![][(~)]             |
|  unknown     | `6[foo]` | `6[foo].b`  | `6[foo].bar`   |  `6(~)`         |  ![][6(~)]            |
|  unknown     | `6[baz]` | `6[baz].b`  | `6[baz].bar`   |  `6(~)`         |  ![][6(~)]            |

Panelcode shorthands are also extensible.

-  a `.name` to tag -- this will also match on the first letter `.n` if not already used.
-  a regular expression for matching the bracket content. 
    ...if this is unambiguous with other shorthands then the code can be used without an identifier
-  a function which produces rowcode.
    -  this could involve a simple lookup table (as in alpha code) or a generator.

So, for example, imagine an encoder and renderer that represents a 'pizza' group, which can be divided into radial slices, beginning at 180 and proceeding counter-clockwise. Slices may be equal or their arcs may be weighted differently according to the arc property `.a`:

`5[3+1.a2+1].pizza`

...specifies three equal slices across the top half of the pizza, followed by a double-slice and a single slice, all read counter-clockwise in a circle. Howeer, without the pizza encoder or renderer, panelcode designates the group `5(~)` and renders -- as a placeholder -- 5 marked panels as an approximation.


### Canonicals

Panelcode's goal is to be writeable and readable through accomodating a variety of shorthands.
However, for the purposes of comparison, search, and resource management (e.g. image generation or URL caching) it is ideal for one layout to have one and only one 'canonical' panelcode representation.

Some advantages of resolving Panelcode to canonical form include:

-   easy readability
-   easy search and pattern matching
-   better caching

#### equivalence of different short forms


Consider the many ways in which one can indicate a 3x3, 9-panel grid in Panelcode. All of these reduce to the canonical representation `3_3_3`
 
|  shorthand   |  string         |  fully expanded             |  Panelcode   |  render      |
|--------------|-----------------|-----------------------------|--------------|--------------|
|              |  `3_3_3`        |  `(1+1+1)_(1+1+1)_(1+1+1)`  |  `3_3_3`     |  ![][3_3_3]  |
|  groups      |  `(3)_(3)_(3)`  |  `(1+1+1)_(1+1+1)_(1+1+1)`  |  `3_3_3`     |  ![][3_3_3]  |
|  hints       |  `3()_3()_3()`  |  `(1+1+1)_(1+1+1)_(1+1+1)`  |  `3_3_3`     |  ![][3_3_3]  |
|  multiplier  |  `3[*3]`        |  `(1+1+1)_(1+1+1)_(1+1+1)`  |  `3_3_3`     |  ![][3_3_3]  |
|  vertical    |  `3_[222].v`    |  `(1+1+1)_(1+1+1)_(1+1+1)`  |  `3_3_3`     |  ![][3_3_3]  |


#### full expansion, then ordered compression

-  Shorthands are always expanded
-  Expanded shorthands are always compressed if possible
-  Contiguous simple row nums are merged (if they have no different properties):
   -   `1+1,1+1` --> `2,2`
   -   `1+1+1+1r2,2+1` -> `3+1r2,3`
   -   `r2+r2+1+1,1+1` = `2r2+2,2`
   -   always!
-  Groups of simple row nums are ungrouped (if they have no different properties):
   -  `(2,2)_2` --> `2_2_2`
   -   always!
-  Properties such as `.c`, `.r`, `.i`, `.blank`, `.uncoded`, `.{userdefined}`
   -   are always alphabetized, e.g.
   -   `(~r2c2+1,1)` --> `(1.c2.r2.uncoded + 1, 1)`
      -  + sorting, serach
      -  ! ...?
-  Group hints always...
   -  ...present
      -  + readability, simplify `3(etc.)_3(etc.)` to `3_3` with regex
      -  ! validation -- can get out of sync
      -  ! required complex logic to generate them for program and/or reader
   -  ...absent ?
      -  + 
      -  ! 
-  For the top level page, `( )` is always...
   -  ...absent
      -  + 
      -  ! 
   -  ...present ?
      -  + 
      -  ! 

rows+groups canonical

`3(r2+1,1)_4(r2+1+r2,1)_4(1+r2+1,2)`

'mixed' --> full
`4(1+r2+1,1+1) --> 4(1+r2+1,2)`

'mixed' --> short
`4(1+r2+1,1+1) --> 4`

shorthand --> full

`3C_4H_4I --> 3(r2+1,1)_4(r2+1+r2,1)_4(1+r2+1,2)`

``(3)_(3)_(3) --> 3_3_3``

`3(r2+1,1)`

canonical_form()







## ----------

## DEV NOTES


#### safe characters

-  http://superuser.com/questions/358855/what-characters-are-safe-in-cross-platform-file-names-for-linux-windows-and-os
-  http://www.mtu.edu/umc/services/web/cms/characters-avoid/
-  https://support.apple.com/en-us/HT202808


#### DEV Idea: nesting and more pythonic syntax

1. What if , worked the same inside and outside groups? ( `_` --> `,` )
2. What if , and + worked the same inside and outside groups?
3. What if the () worked to different levels of nesting?
4. What if parts of the syntax partially mirrored the python () [] {} in some (intuative / data structure) way?

-  http://stackoverflow.com/questions/22391419/what-is-the-difference-between-curly-brace-and-square-bracket-in-python
-  https://docs.python.org/3.3/tutorial/datastructures.html
-  https://docs.python.org/3/library/stdtypes.html#tuple
-  might be interesting to see how python implements a Markdown processor...
   -  https://pypi.python.org/pypi/Markdown
   -  http://daringfireball.net/projects/markdown/

(,) tuples

### DEV Groups: `()`

```xml
<layout>
  <panelgroup>
    <panel /><panel /><panel />
  </panelgroup>
  <panelgroup>
    <panel /><panel />
  </panelgroup>
  <panelgroup>
    <panel /><panel /><panel />
  </panelgroup>
</layout>
```

Conceptually colspans and rowspans are designed to work much like CSS `display:table` or HTML `<table>`. 
However note that column constraints to not hold across outside a row or rowgroup. For example:

```Panelcode
	3_2
```

...renders with each row full-width, whereas an html table does not:

```html
	<table>
		<tr><td></td><td></td><td></td><tr>
		<tr><td></td><td></td><tr>
	</table>
```

<table>
  <tr><td></td><td></td><td></td><tr>
  <tr><td></td><td></td><tr>
</table>

> `panelcode.html_table("1_3")`



```Panelcode
	233(1+r2,1)
	2_5(1+r2+r2+r2,1)_4(r2+r2+1,1)
```


### DEV Insets: `.i( )`

**INSETS are currently not supported in Panelcode, but the specification is under development.**

Insets are panels included within other panels.

They indicated on a rownum with the property `.i`. 

|  shorthand |  shorthand   |  shorthand   |  shorthand   |  description                  |  Panelcode   |  render     |
|------------|--------------|--------------|--------------|-------------------------------|--------------|-------------|
|  `1`       |  `1`         |  `1`         |  `1`         |  no insets                    |  `1`         |  ![][1]     |
|  `1.i1`    |  `1.i(1)`    |  `1.(1)`     |  `1.1`       |  1 inset                      |  `1.i1`      |  ![][1.i1]  |
|  `1.i2`    |  `1.i(2)`    |  `1.(2)`     |  `1.2`       |  2 insets                     |  `1.i2`      |  ![][1.i2]  |
|  `3.i1`    |  `3.i(1)`    |  `3.(1)`     |  `3.1`       |  1 inset each in 3-panel row  |  `3.i1`      |  ![][3.i1]  |
|  `3.i2`    |  `3.i(2)`    |  `3.(2)`     |  `3.2`       |  2 insets each in 3-panel row |  `3.i2`      |  ![][3.i2]  |

The rownum is generally `1`, but insets may be set on all panels in a row. `3.i1` expands to `(1.i1 + 1.i1 + 1.i1)`. This is because the inset is specified for each of the 3 panels in the row. Another way of saying this is that, like multiplication, the inset property is distributive (like all Panelcode properties).

Insets may be either a single panel or a simple row according to their count (`.i1`, `.i2`, `.i3` etc.).

**INSET NESTING INSET GROUPS are currently not supported in Panelcode, but the specification is under development.**

One proposed method is to allow inset of a layout -- a row, group, or series of rows and groups. Panelcode rendering would be recursive.

Nested panels can be specified as a row or panel group.

```Panelcode
	1
        1.i3(r2+1,1)
	1.i(r2+1,1)
	3                    # no insets
	3(1+1.i1+1)          # 1 inset in center panel
	3(1+1.i3+1)          # 3 insets in center panel
	3(1+1.i3(r2+1,1)+1)  # 3 inset rowgroup in center panel
	3(1+1.i(0+0+1)+1)    # insets rowgroup in center panel
	3.i                  # shorthand = 3(1i1+1i1+1i1)
	3.i2                 # shorthand = 3(1i2+1i2+1i2)
```	
	
So, four nested panels:

	1.i1.i1.i1

```Panelcode
	3_1i1_3
	3_1i2_3
	3_1i()_3
	3_1i2_(1,1i
	3_1
	3(1+1i(2))3
```

.i2
.i3

.i(1+r2,1)

-  insets -- row num insets (`1_1.i`)
-  insets -- row num multi-insets (`1_1.i3`)
-  insets -- group insets (`1_3(r2+1.i,1`)
-  insets -- group multi-insets (`1_3(r2+1.i3,1`)
-  ? insets -- row num inset groups (`1_1.i(r2+1,1)`)
-  ? insets -- group inset groups (`1_3(r2+1.i(r2+1,1),1`)

Alternately, the group operator is already for nesting -- so rather than requiring that the top level for groups be the empty page, allow groups to be attached to panels as a property with `.i` or even just `.`:

	1.(3_1.(2_2))

-  `1` panel, with
   -  `.(` an inset layout containing
      -  `3` panels in a row, `_` and
      -  `1` panel, with
         -  `.(` an inset layout containing
             -   `2_2` a 2x2 grid
         -  `.)`
   -  `.)`


#####  DEV inset shorthand

Often it would be nice to keep a row simple (e.g. `3`) and just specify which member panel contains an inset.

```Panelcode
	3.i    # = 3(1i1+1i1+1i1) insets on all row panels
	3.i.1  # = 3(1i1+1+1) inset on panel #1 
	3.i.2  # = 3(1+1i1+1) inset on panel #1
	3.i.3  # = 3(1+1+1i1) inset on panel #1
	...
	5.i.2(r2+2,2) # = 5(r2+1i1+1,2) inset added to the second panel of a group. Notice necessary expansion of r2+2 to specify inset.
```


##### DEV inset alignment?

Inset alignment information is currently outside the scope of panelcode -- insets are displayed either centered or along the bottom of the panel frame.

Inset alignment? Default should be centered, but that is probably rare. Might be interesting to give an inset gravity within a frame -- NSWE, or NE SW etc. Or use something more like what W3c or Imagemagick use for alignment values.

```Panelcode
	1i.n    # = inset North
	1i.s   # = inset SW
	3i.3sw # = ..combine panel num and alignment South, West?

```


### DEV layout compositing

Given two panelcodes, `333` and `2_(r2+2,2)`, each representing a page:

-  `++` = connected page (horizontally, e.g. comic book)
-  `,,` = connected page (vertically, e.g. webtoon)
-   `;` = new page or pagespread

|  Panelcode            |  description            |
| ----------------------|-------------------------|
|  3_3_3++2_2_5(r2+2,2) |  left-right pages       |
|  3_3_3,,2_(r2+2,2)    |  top-bottom pages       |
|  3_3_3++              |  left-right 2pg spread  |
|  3_3_3,,              |  top-bottom 2pg spread  |

![][3_3_3]
![][2_2_5(r2+2,2)]

A fold-out book or accordian book might encode a series of several pages as one spread.

|  Panelcode         |  description                     |
| -------------------|----------------------------------|
|  `212++431`        |  left-right facing 2pgs          |
|  `1,,`             |  a single horizontal centerfold  |
|  `12++43++11++32`  |  fold-out "gateway" 4 pages      |

The main purpose of layout compositing is to distinguish 2pg spreads from single pages. This aids in rendering facing page pairs -- for formats in which this kind of analysis sense (e.g. print formats such as comic books, graphic novels, etc.). However it could support other things.

12 pages from Promethea, re-arranged as a poster (not real code):

```Panelcode
	(32++23++14++32),,(44++12++12++32),,(21++41++31++11),,(1++51++222++1)
	# not real code
```

```Panelcode
	((~)++(~)++(~)++(~)),,((~)++(~)++(~)++(~)),,((~)++(~)++(~)++(~)),,((~)++(~)++(~)++(~))
	# not real code
```


> Poster zones and sections from Meanwhile?

The first ten page-spreads of Scott Pilgrim:

```Panelcode
	1++
	1222++2221
	121++12
	1++
	112++2111
	122++131
	221++311
	414++
	2111++112
	1221++1222
```

#### DEV layout compositing example -- gatefold covers in comics

-  [Example of gatefold cover shown in video](https://youtu.be/h5rSAqJsDf0?t=502) -- the front cover has an extra flap folded inside the first page, which reveals a double-wide front cover. I've also seen images of double-gatefold in which the front and back cover form a diptic, and double gatefold makes it quad wide. 

See also: "[spread](https://en.wikipedia.org/wiki/Glossary_of_comics_terminology#Spread)" leading to "[gatefold](https://en.wikipedia.org/wiki/Gatefold)"

Tinsley has diagrams and explanations of how "wrap around covers" and "gatefold covers" are prepared and folded. (Tinsley, Kevin. _[Digital Prepress for Comic Books]()_. 2009. p33.)

However, compare Chris Ware!


#### DEV layout compositing ideas

1_1
2_2
4_4

I want to arrange these in a square, with 1_1 double-wide.

If this were a single page, it would be defined like this:

```Panelcode
	1_1_(r2+r2+4,4,r2+r2+4,4)
```

If I wanted 1_1 double-tall on the left as a single page, it would look very different.

alternately, through a compositing. What if we added a different brace/bracket for "page" to aid clarity? Although it could hurt URL / filename portability.

Then use c and r spans in exactly the same way in the composite as in a rowgroup:

[1_1]c2,,[2_2]++[4_4]
[1_1]c2,[2_2]+[4_4]
[1,1]c2,[2,2]+[4,4]
[11]c2,[22]+[44]

...which means that a two page spread is just:

[1_2_3]c2

This might be better than `1_2_3++` or ``[1_2_3]++`` as it scales beyond 2-pages, and allows complex constructions of the same kind as rowgroups. So, the Promethea 12pg spread:

`[1]+[1]+[1],[1]+[1]+[1],[1]+[1]+[1],[1]+[1]+[1]`


and a gatefold cover:

`[1]c3`

Could even add several types:

	() = rowgroup
	[] = page
	{} = composite

...to make it explicit -- although I'm not sure that anything needs to be outside the composite, so maybe unnecc.

On the other hand, you could nest arbitrarily deep if you just use '()' for everything.

So instead of:

	{[3_3]+[1_2_3],[3_(r2+1,1)]r2}

It would just be:

	((3_3)+(1_2_3),(3_(r2+1,1))r2)
	
or for that matter, making underscores into +:

	((3+3)+(1+2+3),(3+(r2+1,1))r2)

This last seems extremely hard to read.

But compared to the two-page spread or n-page spread I'm not sure I want to do the dynamic logic on discovering what is a composite, page, rowgroup etc. as this will matter a lot for rendering. It seems much more important for a class of approaches to data that isn't comics. So, maybe for another day.

Right now, the two most common constructions would almost certainly be:

	1_2_3++2_2		# facing pages considered as a single layout
	1_2_3+2_2			#  ...alternate syntax?
	[1_2_3]+[2_2]		#  ...alternate syntax?

	1_2_3++			# a two-page spread
	1_2_3+				#  ...alternate syntax?
	[1_2_3]+			#  ...alternate syntax?
	[1_2_3]c2			#  ...alternate syntax?
	1_2_3c2			#  ...alternate syntax?

The argument for c2 is that it is consistant with rowgroups and more flexible. However, because of the way it visually appears to attach to the '3' it makes the braces seem necessary.


#### DEV layout compositing NEW THOUGHTS

	(3(~),3,3(1.r2+1,1.uncoded),3).c2
	((1+r2,1)).c2
	(1+r2,1).c2
	1+1.r2,1..c2     # or double-dot to avoid wrapping the thing in ()

	can contain, nesting:	1 , 1+1 , 1.r2 , .r2 , r2 , 1() , (), ~, 0, ..c2

...so if 

	(1,2,3)..c2	# two-page wide layout
	(~)		# (~).c2	
	(0)		# (0).c2
	()++()		# combined page spread
	(),,()		# combined page spread
	();();();	# minified page series
	
	
	(3)		# nice property of being python data structure syntax
	(3,3)
	(3,3+3)			# = (3,6)	
	(3,3+(1.r2+1,1))	# 3+ works? What does it mean...?
	(1,2)++(1,3)..c2	# what happens here? does c2 refer to the second layout only, or both?
	((1,2)++(1,3))..c2	# ...better? death by parens?
	(((3)))			# legal, or no? different?
	(3,2+(3,2+(3)))		# deep nesting? which is the top level?

	**later** add  page-compositing operators  ++  ,,  ..  ;

	(1,2,3) = (1,1+1,1+1+1)
	  [1, 1+1, 1+1+1]
	  [[1], [1,1], [1,1,1]]
	
	search [1,2,3]
	search [1,2,3.r2]
	searchany [1,2,3] = [1.?,2.?,3.?]


### DEV Series

A series of panelcodes may be written in a minified 
A Panelcode file consists panelcode strings separated by either line breaks (one per line) or semicolons (or mixed). Panelcode lines may include comments:


What about page numbers? CSV? Part and section structure?

```Panelcode
	## Chapter 1: Asleep
	
	1.	333
	2.	2253
	...
	
	## Chapter 2: Down
	
	#### Ch2. Part 1: Curiouser
	
	1.	123
	2.	11
	...
	
	#### Ch2. Part 2: Among the Mad
	...
```


#### DEV layout compositing and minification

A simple minified string of multiple panelcodes is semi-colon separated:

```Panelcode
	333;131;1;331;323;213;1
```

Here are all of the layouts of Scott Pilgrim vol.1 (160 pages), minified into a single Panelcode string:

> 1++;; 1222;2221;; 121;12;; 1++;; 112;2111;; 122;131;; 221;311;; 414++;; 2111;112;; 1221;1222;; 2222;2222;; 2221;12;; 1212;1221;; 12;11(3C);; 221;1222;; 1(3C);11;; 010;1111;; 1111;111;; 211;2211;; 211;11;; 121;221;; 010;1111;; 111;1222;; 21(3C);1212;; (3C)++;; 122;(3C)11;; (2r+3r,2r,3r,2r)12;212;; (3C)12;122;; 321;2222;; 22(4E);212;; (3C)12;232;; 323;23(3C);; 111;12;; 1(3C);122;; 212;22(3C);; 1111;1111;; _3C++;; 21(3C);221;; 1221;222;; 22(3C);1;; 121;122;; 221;(3C)11;; 322;122;; 1++;; 222;112;; 222;12;; (3C)++;; 12;111;; 111;221;; 112;121;; 121;121;; 111;122;; 222;11;; 1(3D);22(3C);; 122;312;; 122++;; 222;211;; 1(3C);22111;; 12;121;; 1221;1111;; 12(3C);112;; 1++;; 1122;112;; 1212;1111;; (c2+r4,c2,2,1)++;; 111;111;; (3r2+1,1)++;; 12;1(3C);; 12;111;; 311;121;; 11;11;; 1++;; 11++;; 1(3C)++;; 11++;; 1++;; 113;111;; 122;12;; 212;232;; 222;112;; (1+r3,1,1)++;; 

Here they are with no layout compositing information, just serialization:

> 1;; 1222;2221;; 121;12;; 1;; 112;2111;; 122;131;; 221;311;; 414;; 2111;112;; 1221;1222;; 2222;2222;; 2221;12;; 1212;1221;; 12;11(3C);; 221;1222;; 1(3C);11;; 010;1111;; 1111;111;; 211;2211;; 211;11;; 121;221;; 010;1111;; 111;1222;; 21(3C);1212;; (3C);; 122;(3C)11;; (2r+3r,2r,3r,2r)12;212;; (3C)12;122;; 321;2222;; 22(4E);212;; (3C)12;232;; 323;23(3C);; 111;12;; 1(3C);122;; 212;22(3C);; 1111;1111;; _3C;; 21(3C);221;; 1221;222;; 22(3C);1;; 121;122;; 221;(3C)11;; 322;122;; 1;; 222;112;; 222;12;; (3C);; 12;111;; 111;221;; 112;121;; 121;121;; 111;122;; 222;11;; 1(3D);22(3C);; 122;312;; 122;; 222;211;; 1(3C);22111;; 12;121;; 1221;1111;; 12(3C);112;; 1;; 1122;112;; 1212;1111;; (c2+r4,c2,2,1);; 111;111;; (3r2+1,1);; 12;1(3C);; 12;111;; 311;121;; 11;11;; 1;; 11;; 1(3C);; 11;; 1;; 113;111;; 122;12;; 212;232;; 222;112;; (1+r3,1,1);; 


#### DEV serialization example -- converting binary grids and branching comics


Binary grid comics: converting


Data grid for panels in ["Choose Your Own Carl"](http://scottmccloud.com/1-webcomics/carl/3b/cyoc.html):

```
 1 1 1 1 1 0 1 0 0 0 1 0 1 0 1 0
 1 0 1 0 0 0 1 1 1 1 1 1 1 1 1 1
 1 1 1 1 1 0 1 0 1 0 1 0 1 0 1 0
 1 0 1 0 1 0 1 0 1 0 1 0 0 0 1 0
 1 0 1 1 1 1 1 1 1 1 1 1 1 1 1 1
 0 0 0 0 1 0 1 0 1 0 1 0 0 0 1 0
 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1
 0 0 1 0 1 0 0 1 0 0 1 1 0 1 0 0
 1 1 1 1 1 1 1 1 1 0 1 0 0 1 0 1
 0 1 0 0 1 0 0 1 0 0 1 1 1 1 1 1
 1 1 1 1 1 0 1 1 0 0 1 0 0 1 0 1
 0 1 0 0 1 0 0 1 0 1 1 1 1 1 1 1
```


Converting each row into a valid panelcode:

```Panelcode
(1+1+1+1+1+0+1+0+0+0+1+0+1+0+1+0)
(1+0+1+0+0+0+1+1+1+1+1+1+1+1+1+1)
(1+1+1+1+1+0+1+0+1+0+1+0+1+0+1+0)
(1+0+1+0+1+0+1+0+1+0+1+0+0+0+1+0)
(1+0+1+1+1+1+1+1+1+1+1+1+1+1+1+1)
(0+0+0+0+1+0+1+0+1+0+1+0+0+0+1+0)
(1+1+1+1+1+1+1+1+1+1+1+1+1+1+1+1)
(0+0+1+0+1+0+0+1+0+0+1+1+0+1+0+0)
(1+1+1+1+1+1+1+1+1+0+1+0+0+1+0+1)
(0+1+0+0+1+0+0+1+0+0+1+1+1+1+1+1)
(1+1+1+1+1+0+1+1+0+0+1+0+0+1+0+1)
(0+1+0+0+1+0+0+1+0+1+1+1+1+1+1+1)
```

Joining them with underscores and optionally compressing 1+1's into counts. Note that 0+0s must stay separate.

> (5+0+1+0+0+0+1+0+1+0+1+0)_(1+0+1+0+0+0+10)_(5+0+1+0+1+0+1+0+1+0+1+0)_(1+0+1+0+1+0+1+0+1+0+1+0+0+0+1+0)_(1+0+14)_(0+0+0+0+1+0+1+0+1+0+1+0+0+0+1+0)_(16)_(0+0+1+0+1+0+0+1+0+0+2+0+1+0+0)_(9+0+1+0+0+1+0+1)_(0+1+0+0+1+0+0+1+0+0+6)_(5+0+2+0+0+1+0+0+1+0+1)_(0+1+0+0+1+0+0+1+0+7)



### DEV Shorthands


#### DEV Quick code

Serialization (`;`) and compositing (`++`, `,,`) may be combined quick syntax strings -- or may combine a mix of quick syntax strings and other panelcode.

The simple syntax detector will assume that a panelcode string is written in simple syntax if it:

  1. contains 2 or more contiguous digits
  2. does not contain row separators `_`, groups `()`, or shortcodes `[]`

Note however that row separators `_` are required for any layout referring to a two-digit number greater than 9. 

```Panelcode
	1212     # = 1 + 2 + 1 + 2
	12_12    # = 12 + 12
	1_2_12   # = 1 + 2 + 12
```

If used, row separators must be used throughout a Panelcode line -- they cannot be mixed.

```Panelcode
	12112_12   # = 12112 + 12 !!
	           # ...NOT 1 + 2 + 1 + 1 + 2 + 12
```

![][2_2_2_1_1_2_1]
![][3_3_3_3_3]

Limitations of quick syntax:

-  no row counts > 9, e.g. `1212` = `1_2_1_2`; for 12s, write `12_12`.
-  pages with a single row count > 9 must be escaped in a group.
   -  `12`   --> `1_2` ** I"M CONCERNED ABOUT THIS **
   -  `12_`  --> `(12)` ** MAYBE?
   -  `12()` --> `(12)` ** MAYBE?
   -  `(12)` --> `(12)` ** MAYBE? For single rows with 2-digit panel counts, use a group.


> ... NO: 233(1+r2,1)


#### DEV Vertical shorthand


Notice that verticode can capture everything that alphacode can -- it is less concise, but more flexible.

|  rowcode        |  image                |  alpha  |  verticode |  short   |
|-----------------|-----------------------|---------|------------|----------|
|  `3(r2+1,1)`    |  ![3C][3(r2+1,1)]     |  (C)    |  (v12)     |  (3C)    |
|  `3(1+r2,1)`    |  ![3D][3(1+r2,1)]     |  (D)    |  (v21)     |  (3D)    |
|  `4(r3+1,1,1)`  |  ![4E][4(r3+1,1,1)]   |  (E)    |  (v13)     |  4E / 4C |
|  `4(1+r3,1,1)`  |  ![4D][4(1+r3,1,1)]   |  (B)    |  (v31)     |  4D      |
|  `5(1+r2+1,2)`  |  ![5I][5(1+r2+1,2)]   |  (I)    |  (v212)    |  5I      |
|  `5(r2+1+r2,1)` |  ![5H][5(r2+1+r2,1)]  |  (O)    |  (v121)    |  5H      |
|  `5(r2+2,2)`    |  ![5C][5(r2+2,2)]     |         |  (v122)    |  5C      |
|  `5(2+r2,2)`    |  ![5C][5(2+r2,2)]     |         |  (v221)    |  5D      |

A strange issue -- verticode does not (or does it? sometimes?) specify in "reading order" -- so needs to be converted into panel code for panel ids -- se for example (v124)



**Note**: Generated verticode gets tricky e.g. mismatched rows requires lowest common multiple to be expressed. So, for example, `[5432V]` requires 60 rows to create the correct vertical divisions.

1. `[5432V]`
2. compute the lowest common multiple for the set (lcmm): 60
3. compute unit scaling factor for each column:
   -  5 scale = 60/5 = 12r
   -  4 scale = 60/4 = 15r
   -  3 scale = 60/3 = 20r
   -  2 scale = 60/2 = 30r
4. generate verticode in terms of scales

Here are were row declarations would be made in an HTML table statement:

|     | 5        | 4        | 3        | 2        |
|-----|----------|----------|----------|----------|
| 0.  | 1.12r    | 1.15r    | 1.20r    | 1.30r    |
| 1.  |          |          |          |          |  
| 2.  |          |          |          |          |  
| 3.  |          |          |          |          |  
| 4.  |          |          |          |          |  
| 5.  |          |          |          |          |  
| 6.  |          |          |          |          |  
| 7.  |          |          |          |          |  
| 8.  |          |          |          |          |  
| 9.  |          |          |          |          |  
| 10. |          |          |          |          |  
| 11. | -------- |          |          |          |  
| 12. | 1.12r    |          |          |          |  
| 13. |          |          |          |          |  
| 14. |          | -------- |          |          |  
| 15. |          | 1.15r    |          |          |  
| 16. |          |          |          |          |  
| 17. |          |          |          |          |  
| 18. |          |          |          |          |  
| 19. |          |          | -------- |          |  
| 20. |          |          | 1.20r    |          |  
| 21. |          |          |          |          |  
| 22. |          |          |          |          |  
| 23. | -------- |          |          |          |  
| 24. | 1.12r    |          |          |          |  
| 25. |          |          |          |          |  
| 26. |          |          |          |          |  
| 27. |          |          |          |          |  
| 28. |          |          |          |          |  
| 29. |          | -------- |          | -------- |  
| 30. |          | 1.15r    |          | 1.30r    |  
| 31. |          |          |          |          |  
| 32. |          |          |          |          |  
| 33. |          |          |          |          |  
| 34. |          |          |          |          |  
| 35. | -------- |          |          |          |  
| 36. | 1.12r    |          |          |          |  
| 37. |          |          |          |          |  
| 38. |          |          |          |          |  
| 39. |          |          | -------- |          |  
| 40. |          |          | 1.20r    |          |  
| 41. |          |          |          |          |  
| 42. |          |          |          |          |  
| 43. |          |          |          |          |  
| 44. |          | -------- |          |          |  
| 45. |          | 1.15r    |          |          |  
| 46. |          |          |          |          |  
| 47. | -------- |          |          |          |  
| 48. | 1.12r    |          |          |          |  
| 49. |          |          |          |          |  
| 50. |          |          |          |          |  
| 51. |          |          |          |          |  
| 52. |          |          |          |          |  
| 53. |          |          |          |          |  
| 54. |          |          |          |          |  
| 55. |          |          |          |          |  
| 56. |          |          |          |          |  
| 57. |          |          |          |          |  
| 58. |          |          |          |          |  
| 59. | -------- | -------- | -------- | -------- |  

And here are those row declarations in rowcode: 

(12r + 15r + 20r + 30r,,,,,,,,,,,12r,,15r,,,,20r,,,12r,,,,,15r + 30r,,,,,12r,,,15r,,,,15r,,12r,,,,,,,,,,,)

...or, in vertical shorthand:

`[5432V]`

Note that in rendering vertical codes all row paddings etc. *have* to be 0 in rendering if groups that are only 5 rows talls are, in practice, rendering 60 rows.



A complete solution to computing the lowest common multiple (lcm) for sets of numbers greater than 2 (lcmm), in python and using reduce, appears here:

```python

	# http://stackoverflow.com/questions/147515/least-common-multiple-for-3-or-more-numbers
	
	def gcd(a, b):
	    """Return greatest common divisor using Euclid's Algorithm."""
	    while b:      
	        a, b = b, a % b
	    return a
	
	def lcm(a, b):
	    """Return lowest common multiple."""
	    return a * b // gcd(a, b)
	
	def lcmm(*args):
	    """Return lcm of args."""   
	    return reduce(lcm, args)
```

> The other way to find the lowest common multiple is to list the prime factors for each number. Remove the prime factors both numbers have in common. Multiply one of the numbers by the remaining prime factors of the other number. The result will be the lowest common multiple.
>
> **Example:**  
> What is the lowest common multiple of 25 and 30?
> -  The prime factors of 25 are 5 x 5.
> -  The prime factors of 30 are 2 x 3 x 5.
> -  Remove the 5 that 25 and 30 have in common as a prime factor.
> -  Multiply 25 by the remaining prime factors of 30.
> -  25 x 2 x 3 = 150.
>
> The lowest common multiple of 25 and 30 is 150.  
> http://www.factmonster.com/ipka/A0933352.html




#### DEV Extending Shorthands


##### DEV Example: a grid shorthand

**Note**: Grids can already be concisely represented with the multiplier, e.g. `2[*2]`. This is an example of developing a shorthand extension.

|  shorthand  |  short   |  full          |  rowcode             |  render                   |
|-------------|----------|----------------|----------------------|---------------------------|
|  grid       |  `[2x2]` |  `[2x2].grid`  |  `2_2`               |  ![][2_2]                 |
|  grid       |  `[3x4]` |  `[3x4].grid`  |  `3_3_3_3`           |  ![][3_3_3_3]             |
|  grid       |  `[6x9]` |  `[6x9].grid`  |  `6_6_6_6_6_6_6_6_6` |  ![][6_6_6_6_6_6_6_6_6]   |

>  (see for example swimming page from Concrete)

The possible grid codes are essentially multiplication tables.

	1x1  1x2  1x3  1x4  ...
	2x1  2x2  2x3  2x4  ...
	3x1  3x2  3x3  3x4  ...
	4x1  4x2  4x3  4x4  ...
	...  ...  ...  ...  ...

If we support up to `[4x4]` there 16 codes (4^2); up to `[9x9]` there are 81 codes (9^2). Because there is no such thing as `[1x2x3]`, and because this isn't combinatoric, and because it is highly unlikely we will be getting grids 10x10 and higher, we could choose to simply write a lookup table which matches a code and replaces it.

	1x1	
	1x2
	1x3
	...
	9x8
	9x9

Of course, it is more elegant to write a generator. In Python this is incredibly easy -- we take the first part as a string, and the second an integer, and then multiply the string by the integer:

```python
# [python code here]
```

Here are some tests for our grid shorthand

```python
	shorthand_grid.validate():
	  # [2x3] --> True
	  # [2_3] --> False
	  # [2+3r] --> False
	  # [2+3] --> False
	
	shorthand_grid.to_rows(): 
	  # [3x4] --> 3_3_3_3
	  # [2x3]_1_[4x2] --> 2_2_2_1_4_4
	  # [2x3x4] --> Error: more than two grid terms.
	  # [x3_4] --> Error: grid without width.
	  # [4_x3] --> Error: grid without width.
	  # [3x_4] --> Error: grid without height.
	  # [4_3x] --> Error: grid without height.
	
	shorthand_grid.to_group(): # ...?
	  # [3x4] --> 3(3)_3(3)_3(3)_3(3)
	
	zshorthand_grid.to_expanded(): # ...?
	  # 3x4 --> 3(1+1+1)_3(1+1+1)_3(1+1+1)_3(1+1+1)
```

Potential Questions re:grid shorthand groups:

-  What number / percentage of the pages in x...
   -  ...contain a grid?
   -  ...contain a perfect grid (2x2,3x3,4x4...)
-  Which page in x...
   -  ...contains the largest dimensioned grid?
   -  ...contains the largest number of separate grids?
-  Which projects...
   -  ...contain the fewest grids, or no grids?
   -  ...contain the most grids, or only grids?


### DEV RTL encoding

Already have sections on RTL in rendering, but it might be important to point out here:

-  Reading order and encoding order
-  Encoding manga in Japanese reading order

We can use the syntax (prefix or suffix) to indicate what reading order is encoded. This could matter for queries across collections that contain both. Or just a header for the whole file!


### DEV row group height scaling 

	(123)..heights(121)

Here the center row of two is twice as tall as the other rows. I think that css grid has a way of doing this -- or I can just apply scaling manually in css / etc. if the renderer supports it (e.g. graphviz record labels don't).

## ----------

